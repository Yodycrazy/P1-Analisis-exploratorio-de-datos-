# -*- coding: utf-8 -*-
"""p2_proyecto.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mF04gZyUHbWDDZPuDUVF82nB593hPYts

Base de datos covid 19
"""

# Importar librerias
import seaborn as sns
import pandas as pd
from sklearn.linear_model import LinearRegression
import numpy as np
from sklearn.metrics import r2_score
import matplotlib.pyplot as plt

# Cargar datos
df = pd.read_csv("/content/data_covid1.csv")
df.head(2)

# Convertir la columna "fecha_reporte_web" al formato "2020-11-08"
df['fecha reporte web'] = pd.to_datetime(df['fecha reporte web']).dt.strftime('%Y-%m-%d')
df

# Convertir la columna "Fecha de notificación" al formato "2020-11-08"
df['Fecha de notificación'] = pd.to_datetime(df['Fecha de notificación']).dt.strftime('%Y-%m-%d')
df

# Convertir la columna "Fecha de diagnóstico" al formato "2020-11-08"
df['Fecha de diagnóstico'] = pd.to_datetime(df['Fecha de diagnóstico']).dt.strftime('%Y-%m-%d')
df

df.keys()

df.drop(columns = 'Unnamed: 0', inplace = True)
df

df.keys()

df['Fecha de diagnóstico'] = pd.to_datetime(df['Fecha de diagnóstico'])
df['Año'] = df['Fecha de diagnóstico'].apply(lambda x: x.year)
df

df['Año'] = df['Año'].fillna(0).astype(int)
df

import matplotlib.pyplot as plt

# Evolución de casos de COVID-19 por día (la cantidad de casos reportados por fecha para ver cómo evoluciona la pandemia.)
df['fecha reporte web'] = pd.to_datetime(df['fecha reporte web'])
df.set_index('fecha reporte web', inplace=True)

df.resample('D').size().plot()
plt.title('Evolución de casos de COVID-19 por día')
plt.xlabel('Fecha')
plt.ylabel('Número de casos')
plt.show()

#Histograma con la distribución de casos entre diferentes grupos de edad.
df['Edad'].plot.hist(bins=range(0, 100, 10))
plt.title('Distribución de casos de COVID-19 por edad')
plt.xlabel('Edad')
plt.ylabel('Frecuencia')
plt.show()

#los municipios con más casos reportados Top 10
df['Nombre municipio'].value_counts().head(10).plot.bar()
plt.title('Top 10 municipios con más casos de COVID-19')
plt.xlabel('Municipio')
plt.ylabel('Número de casos')
plt.xticks(rotation=45)
plt.show()

#Un gráfico de barras puede comparar el número de casos entre hombres y mujeres
df['Sexo'].value_counts().plot.bar()
plt.title('Casos de COVID-19 por sexo')
plt.xlabel('Sexo')
plt.ylabel('Número de casos')
plt.show()

df.Estado.value_counts(normalize = True) * 100

df.Recuperado.value_counts(normalize = True) * 100

# Agrupamos los datos por 'Año' y 'Estado'
conteo_estado_por_año = df.groupby(['Año', 'Estado']).size().unstack(fill_value=0)
conteo_estado_por_año

# Reemplazar el valor '0' por '2019' en la columna 'Año'
df['Año'] = df['Año'].replace(0, '2019')
df['Año']

conteo_estado_por_año.Fallecido

#Estado de los casos (Recuperados, Activos, Fallecidos):
#Un gráfico de pastel puede ilustrar la proporción de casos en diferentes estados
df['Recuperado'].value_counts().plot.pie(autopct='%1.1f%%', figsize=(10, 10), legend=True)
plt.title('Estado de los casos de COVID-19')
plt.ylabel('')
plt.show()

df_2 = pd.read_excel('/content/Municipios.xlsx')
df_2

lat = df_2['lat'].values
lon = df_2['long'].values

lat[2], lon[2]

!pip install haversine

# Calcular arreglo de distancias de 26x26
#Method 1 : Para calcular distancias
import haversine as hs
from haversine import Unit
def distancias(lat,lon):
  resultado = []
  for i in range(lat.shape[0]):
    for j in range(lon.shape[0]):
      result=hs.haversine((lat[i],lon[i]),(lat[j],lon[j]),unit=Unit.KILOMETERS)
      resultado.append(result)
  return resultado

resultado = distancias(lat,lon)

len(resultado), 26*26

import numpy as np

# Convertir la lista 'resultado' en un array de NumPy
resultado_array = np.array(resultado)

# Ahora puedes usar '.size' en 'resultado_array'
if resultado_array.size == 26*26:
    distances = resultado_array.reshape((26,26))
else:
    print(f"El número de elementos es {resultado_array.size}, no se puede reformar a (26,26)")

import pandas as pd

# Hacer una copia del DataFrame original
df_copia = df.copy()

# Convertir todos los valores posibles a numéricos en la copia y los que no se puedan convertir a NaN
df_copia['Estado'] = pd.to_numeric(df_copia['Estado'], errors='coerce')

# Eliminar las filas con NaN si no son necesarias para tu análisis
df_copia = df_copia.dropna(subset=['Estado'])

!pip install sidetable

import pandas as pd
import sidetable

# Asegúrate de tener instalado Sidetable, si no, instálalo con pip install sidetable

# Utilizamos el método 'freq' de Sidetable para obtener la frecuencia de ocurrencias por 'Nombre municipio' y 'Estado'.
df_frecuencia = df.stb.freq(['Nombre municipio', 'Estado'])

# Ahora, creamos una tabla pivote para visualizar mejor los datos.
tabla_resumen = pd.pivot_table(df_frecuencia, values='count', index='Nombre municipio', columns='Estado', fill_value=0)

# La tabla pivote 'tabla_resumen' mostrará cada municipio con la cantidad de personas en cada estado de salud.
print(tabla_resumen)

import folium

# Asumiendo que 'tabla_resumen' contiene la cantidad de personas por municipio y estado.
# Asumiendo que 'df_2' contiene las coordenadas de los municipios.

# Crear un mapa base
m = folium.Map(location=[4.60971, -74.08175], zoom_start=8)  # Coordenadas del centro de Cundinamarca, Colombia

# Colores para cada estado de salud
colores = {
    'Leve': 'green',
    'Fallecido': 'black',
    'Moderado': 'orange',
    'Grave': 'red'
}

# Iterar sobre la tabla resumen para añadir los marcadores
for municipio in tabla_resumen.index:
    for estado in colores.keys():  # Asegurarse de iterar sobre todos los estados posibles
        cantidad = tabla_resumen.loc[municipio, estado] if estado in tabla_resumen.columns else 0
        if cantidad > 0:  # Solo añadir marcadores si hay casos
            # Buscar las coordenadas del municipio en 'df_2'
            if municipio in df_2['Municipio'].values:
                indice = df_2[df_2['Municipio'] == municipio].index[0]
                latitud = df_2['lat'].iloc[indice]
                longitud = df_2['long'].iloc[indice]

                # Añadir el marcador al mapa
                folium.Marker(
                    [latitud, longitud],
                    popup=f"{municipio}: {cantidad} personas - {estado}",
                    icon=folium.Icon(color=colores[estado])
                ).add_to(m)

# Mostrar el mapa
m

import folium

# Asumiendo que 'tabla_resumen' es la tabla que acabas de crear y contiene la cantidad de personas por municipio y estado.
# También asumimos que 'df_2' es tu DataFrame que contiene las coordenadas de los municipios.

# Crear un mapa base
m = folium.Map(location=[4.60971, -74.08175], zoom_start=8)  # Coordenadas aproximadas del centro de Cundinamarca, Colombia

# Colores para cada estado de salud
colores = {
    'Leve': 'green',
    'Fallecido': 'black',
    'Moderado': 'orange',
    'Grave': 'red'
}

# Iterar sobre la tabla resumen para añadir los marcadores con tooltip
for municipio in tabla_resumen.index:
    # Inicializar una lista para guardar la información de tooltip
    info_tooltip = [municipio]  # Agregar el nombre del municipio al principio de la lista
    for estado in tabla_resumen.columns:
        cantidad = tabla_resumen.loc[municipio, estado]
        if cantidad > 0:  # Solo añadir información si hay casos
            info_tooltip.append(f"{cantidad} {estado}")
            color_marcador = colores[estado]  # Esto establece el color del último estado en la lista, puedes ajustarlo según tus necesidades

    # Buscar las coordenadas del municipio en 'df_2'
    if municipio in df_2['Municipio'].values:
        indice = df_2[df_2['Municipio'] == municipio].index[0]
        latitud = df_2['lat'].iloc[indice]
        longitud = df_2['long'].iloc[indice]

        # Añadir el marcador al mapa con tooltip
        folium.Marker(
            [latitud, longitud],
            tooltip=' - '.join(info_tooltip),  # Unir toda la información con ' - '
            icon=folium.Icon(color=color_marcador)
        ).add_to(m)

# Mostrar el mapa
m

m.save('mapa.html')

# Asumiendo que 'tabla_resumen' contiene la cantidad de personas en estado 'Leve' por municipio.

# Ordenar los municipios por la cantidad de personas en estado 'Leve'
municipios_ordenados = tabla_resumen.sort_values(by='Leve', ascending=False).index.tolist()

# Crear una ruta de distribución de vacunas
ruta_vacunacion = []
for municipio in municipios_ordenados:
    # Añadir el municipio a la ruta de vacunación
    ruta_vacunacion.append(municipio)

# La variable 'ruta_vacunacion' ahora contiene los municipios ordenados de mayor a menor según la cantidad de personas en estado 'Leve'

import folium

# Asumiendo que 'tabla_resumen' y 'df_2' están definidos como antes.

# Crear un mapa base
m = folium.Map(location=[4.60971, -74.08175], zoom_start=8)

# Colores para cada estado de salud
colores = {
    'Leve': 'green',
    'Fallecido': 'black',
    'Moderado': 'orange',
    'Grave': 'red'
}

# Ordenar los municipios por la cantidad de personas en estado 'Leve'
municipios_ordenados = tabla_resumen.sort_values(by='Leve', ascending=False).index.tolist()

# Lista para guardar las coordenadas de los municipios en la ruta
coordenadas_ruta = []

# Iterar sobre los municipios ordenados para añadir los marcadores y guardar las coordenadas
for municipio in municipios_ordenados:
    if municipio in df_2['Municipio'].values:
        indice = df_2[df_2['Municipio'] == municipio].index[0]
        latitud = df_2['lat'].iloc[indice]
        longitud = df_2['long'].iloc[indice]
        coordenadas_ruta.append((latitud, longitud))

        # Añadir marcadores para cada municipio
        folium.Marker(
            [latitud, longitud],
            tooltip=municipio,
            icon=folium.Icon(color='blue')
        ).add_to(m)

# Añadir líneas al mapa para mostrar la ruta
for i in range(len(coordenadas_ruta)-1):
    folium.PolyLine([coordenadas_ruta[i], coordenadas_ruta[i+1]], color='blue').add_to(m)

# Mostrar el mapa
m

""" resumen de la ruta de vacunación que establecimos basada en la cantidad de personas en estado “Leve” en cada municipio:

Ordenamos los municipios según la cantidad de personas en estado “Leve”, de mayor a menor.
Creamos una lista que representa la ruta de vacunación, incluyendo los municipios en el orden determinado.
Añadimos marcadores en el mapa para cada municipio utilizando Folium.
Dibujamos líneas entre los marcadores para visualizar la ruta de vacunación.
La ruta comienza en el municipio con la mayor cantidad de personas en estado “Leve” y continúa secuencialmente hasta el municipio con la menor cantidad. Esto asegura que las vacunas se distribuyan primero a los lugares con más casos “Leves”, optimizando así la entrega de recursos donde más se necesitan.
"""

# Ordenar los municipios por la cantidad de personas en estado 'Leve' de menor a mayor lo que indica la prioridad de la vacunación,
### si quisieramos de mayor a menor seria ascending=False
municipios_ordenados = tabla_resumen.sort_values(by='Leve', ascending=True).index.tolist()

# Imprimir la lista de municipios ordenados
for i, municipio in enumerate(municipios_ordenados, start=1):
    print(f"{i}. {municipio}")

import matplotlib.pyplot as plt

# Filtrar los municipios que tienen más de 0 personas en estado 'Leve'
municipios_con_datos = tabla_resumen[tabla_resumen['Leve'] > 0]

# Ordenar los municipios filtrados por la cantidad de personas en estado 'Leve' de menor a mayor
municipios_ordenados = municipios_con_datos.sort_values(by='Leve', ascending=True)

# Crear un gráfico de barras
plt.figure(figsize=(6, 20))
barras = plt.barh(municipios_ordenados.index, municipios_ordenados['Leve'], color='skyblue')

# Añadir los números al final de cada barra
for barra in barras:
    plt.text(
        barra.get_width(),  # Posición x (final de la barra)
        barra.get_y() + barra.get_height() / 2,  # Posición y (centro de la barra)
        int(barra.get_width()),  # Valor numérico a mostrar
        va='center'  # Alineación vertical en el centro
    )

plt.xlabel('Cantidad de Personas en Estado Leve')
plt.title('Prioridad de Vacunación por Municipio (Excluyendo Municipios sin Casos Leves)')
plt.gca().invert_yaxis()  # Invertir el eje y para que el municipio con más casos esté arriba
plt.show()